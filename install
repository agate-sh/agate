#!/usr/bin/env bash

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Agent-specific configuration
get_agent_color() {
    case "$1" in
        claude)   printf "\033[38;2;218;119;86m" ;;    # #da7756
        amp)      printf "\033[38;2;182;191;105m" ;;   # #b6bf69
        gemini)   printf "\033[38;2;205;169;252m" ;;   # #cda9fc
        codex)    printf "\033[38;2;108;144;142m" ;;   # #6c908e
        opencode) printf "\033[38;2;255;186;136m" ;;   # #ffba88
        cursor)   printf "\033[38;2;255;255;255m" ;;   # #ffffff
        copilot)  printf "\033[38;2;129;161;190m" ;;   # #81a1be
        cn)       printf "\033[38;2;55;130;166m" ;;    # #3782a6
        *)        printf "" ;;
    esac
}

get_agent_name() {
    case "$1" in
        claude)   echo "Claude" ;;
        amp)      echo "Amp" ;;
        gemini)   echo "Gemini" ;;
        codex)    echo "Codex" ;;
        opencode) echo "OpenCode" ;;
        cursor)   echo "Cursor" ;;
        copilot)  echo "GitHub Copilot" ;;
        cn)       echo "Continue" ;;
        *)        echo "" ;;
    esac
}

# Configuration
REPO_OWNER="agate-sh"
REPO_NAME="agate"
BINARY_NAME="agate"
INSTALL_DIR="$HOME/.agate/bin"
GITHUB_BASE_URL="https://github.com/${REPO_OWNER}/${REPO_NAME}"

# Print functions (inspired by Cursor's approach)
print_step() {
    printf "\n${CYAN}${BOLD}▸${NC} %s\n" "$1"
}

print_success() {
    printf "${GREEN}${BOLD}✓${NC} %s\n" "$1"
}

print_error() {
    printf "${RED}${BOLD}✗${NC} %s\n" "$1" >&2
}

print_warn() {
    printf "${YELLOW}${BOLD}⚠${NC} %s\n" "$1"
}

print_info() {
    printf "  ${CYAN}%s${NC}\n" "$1"
}

print_dim() {
    printf "\033[2m%s${NC}\n" "$1"
}

# Legacy Helper functions
info() {
    printf "${CYAN}▸${NC} %s\n" "$1"
}

success() {
    printf "${GREEN}✓${NC} %s\n" "$1"
}

error() {
    printf "${RED}✗${NC} %s\n" "$1" >&2
}

warn() {
    printf "${YELLOW}⚠${NC} %s\n" "$1"
}


die() {
    print_error "$1"
    echo ""
    printf "${RED}┌─────────────────────────────────────────────────────────────┐${NC}\n"
    printf "${RED}│${NC} ${BOLD}Installation failed${NC}                                         ${RED}│${NC}\n"
    printf "${RED}│${NC}                                                             ${RED}│${NC}\n"
    printf "${RED}│${NC} For help, please open an issue:                             ${RED}│${NC}\n"
    printf "${RED}│${NC} \033[2m\033[4mhttps://github.com/agate-sh/agate/issues/new${NC}                ${RED}│${NC}\n"
    printf "${RED}└─────────────────────────────────────────────────────────────┘${NC}\n"
    exit 1
}

# Detect OS and architecture
detect_platform() {
    local os arch

    # Detect OS
    case "$(uname -s)" in
        Darwin*)
            os="darwin"
            ;;
        Linux*)
            os="linux"
            ;;
        MINGW* | MSYS* | CYGWIN*)
            os="windows"
            ;;
        *)
            die "Unsupported operating system: $(uname -s)"
            ;;
    esac

    # Detect architecture
    case "$(uname -m)" in
        x86_64 | amd64)
            # Check if running under Rosetta 2 on macOS
            if [[ "$os" == "darwin" ]] && [[ "$(sysctl -n sysctl.proc_translated 2>/dev/null)" == "1" ]]; then
                arch="arm64"
            else
                arch="amd64"
            fi
            ;;
        arm64 | aarch64)
            arch="arm64"
            ;;
        armv7l | armv6l)
            arch="arm"
            ;;
        *)
            die "Unsupported architecture: $(uname -m)"
            ;;
    esac

    echo "${os}_${arch}"
}

# Get the latest version from GitHub
get_latest_version() {
    local version
    version=$(curl -sS "https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/releases/latest" | \
              grep '"tag_name"' | \
              sed -E 's/.*"v?([^"]+)".*/\1/')

    if [[ -z "$version" ]]; then
        return 1
    fi

    echo "$version"
}

# Check if a command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Check and install dependencies
check_dependencies() {
    local missing_deps=()
    local found_deps=()

    # Check for curl (still needed for downloading)
    if ! command_exists curl; then
        die "curl is required but not installed. Please install curl and try again."
    fi

    # Check for agent CLI if specified
    if [[ -n "$agent" ]]; then
        if command_exists "$agent"; then
            found_deps+=("$agent")
        else
            missing_deps+=("$agent")
        fi
    fi

    # Check for docker
    if command_exists docker; then
        found_deps+=("docker")
    else
        missing_deps+=("docker")
    fi

    # Check for gh (GitHub CLI)
    if command_exists gh; then
        found_deps+=("gh")
    else
        missing_deps+=("gh")
    fi

    # Check for fzf and install if missing
    if ! command_exists fzf; then
        print_info "Installing fzf, a command-line fuzzy finder"
        install_fzf
        if command_exists fzf; then
            found_deps+=("fzf")
        else
            missing_deps+=("fzf")
        fi
    else
        found_deps+=("fzf")
    fi

    # Report missing dependencies
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        for dep in "${missing_deps[@]}"; do
            if [[ "$dep" == "$agent" ]]; then
                print_warn "${AGENT_COLOR}${dep}${NC} not found. You'll need to install it separately."
            else
                print_warn "${dep} not found. You'll need to install it separately."
            fi
        done
    fi

    # Show found dependencies
    if [[ ${#found_deps[@]} -gt 0 ]]; then
        local deps_list
        deps_list=$(IFS=', '; echo "${found_deps[*]}")
        printf "${GREEN}${BOLD}✓${NC} Dependencies found \033[2m($deps_list)${NC}\n"
    fi
}

# Install fzf using the universal git method
install_fzf() {
    # Use the official fzf installation method that works across all platforms
    if [[ -d ~/.fzf ]]; then
        # fzf directory already exists, try to update
        cd ~/.fzf && git pull >/dev/null 2>&1 && ./install --bin >/dev/null 2>&1
    else
        # Clone and install fzf
        git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf >/dev/null 2>&1 && \
        ~/.fzf/install --bin >/dev/null 2>&1
    fi

    # Add to PATH for current session if not already there
    if [[ ":$PATH:" != *":$HOME/.fzf/bin:"* ]]; then
        export PATH="$HOME/.fzf/bin:$PATH"
    fi
}

# Install tmux based on the OS
install_tmux() {
    info "Installing tmux..."

    case "$(uname -s)" in
        Darwin*)
            if command_exists brew; then
                brew install tmux || die "Failed to install tmux via Homebrew"
            else
                die "Homebrew is required to install tmux on macOS. Visit https://brew.sh"
            fi
            ;;
        Linux*)
            if command_exists apt-get; then
                sudo apt-get update && sudo apt-get install -y tmux || die "Failed to install tmux"
            elif command_exists dnf; then
                sudo dnf install -y tmux || die "Failed to install tmux"
            elif command_exists yum; then
                sudo yum install -y tmux || die "Failed to install tmux"
            elif command_exists pacman; then
                sudo pacman -S --noconfirm tmux || die "Failed to install tmux"
            elif command_exists apk; then
                sudo apk add --no-cache tmux || die "Failed to install tmux"
            else
                die "Unable to install tmux. Please install it manually."
            fi
            ;;
        *)
            die "Automatic tmux installation not supported on this OS. Please install manually."
            ;;
    esac

    print_success "tmux installed successfully"
}

# Download and install the binary
install_agate() {
    local platform="$1"
    local version="$2"
    local install_path="${INSTALL_DIR}/${BINARY_NAME}"
    local temp_dir

    # Create temporary directory
    temp_dir=$(mktemp -d) || die "Failed to create temporary directory"
    trap "rm -rf '$temp_dir'" EXIT

    # Determine archive format
    local archive_ext
    case "$platform" in
        windows*)
            archive_ext=".zip"
            install_path="${install_path}.exe"
            ;;
        *)
            archive_ext=".tar.gz"
            ;;
    esac

    # Construct download URL
    local archive_name="${BINARY_NAME}_${version}_${platform}${archive_ext}"
    local download_url="${GITHUB_BASE_URL}/releases/download/v${version}/${archive_name}"

    # Download the archive
    if ! curl -sS -L -f -o "${temp_dir}/${archive_name}" "$download_url"; then
        die "Failed to download Agate v${version} for ${platform}"
    fi

    # Extract the archive
    cd "$temp_dir"
    case "$archive_ext" in
        .tar.gz)
            tar xzf "$archive_name" || die "Failed to extract archive"
            ;;
        .zip)
            unzip -q "$archive_name" || die "Failed to extract archive"
            ;;
    esac

    # Create install directory
    mkdir -p "$INSTALL_DIR" || die "Failed to create installation directory"

    # Move binary to installation directory
    local binary_file="${BINARY_NAME}"
    [[ "$platform" == windows* ]] && binary_file="${binary_file}.exe"

    if [[ ! -f "$binary_file" ]]; then
        die "Binary not found in archive"
    fi

    mv "$binary_file" "$install_path" || die "Failed to install binary"
    chmod +x "$install_path" || die "Failed to make binary executable"

    print_success "Agate installed to: $install_path"
}

# Update shell configuration
update_shell_config() {
    header "Configuring Shell"

    local shell_config
    local shell_name

    # Detect shell configuration file
    case "${SHELL}" in
        */bash)
            shell_name="bash"
            if [[ -f "$HOME/.bash_profile" ]]; then
                shell_config="$HOME/.bash_profile"
            else
                shell_config="$HOME/.bashrc"
            fi
            ;;
        */zsh)
            shell_name="zsh"
            shell_config="$HOME/.zshrc"
            ;;
        */fish)
            shell_name="fish"
            shell_config="$HOME/.config/fish/config.fish"
            ;;
        *)
            shell_name="unknown"
            shell_config=""
            ;;
    esac

    # Check if directory is already in PATH
    if [[ ":$PATH:" == *":${INSTALL_DIR}:"* ]]; then
        success "Installation directory already in PATH"
        return
    fi

    # Add to PATH
    if [[ -n "$shell_config" ]]; then
        info "Adding ${INSTALL_DIR} to PATH in ${shell_config}"

        # Create config file if it doesn't exist
        [[ ! -f "$shell_config" ]] && touch "$shell_config"

        # Add PATH export
        if [[ "$shell_name" == "fish" ]]; then
            echo "" >> "$shell_config"
            echo "# Agate" >> "$shell_config"
            echo "set -gx PATH \$PATH ${INSTALL_DIR}" >> "$shell_config"
        else
            echo "" >> "$shell_config"
            echo "# Agate" >> "$shell_config"
            echo "export PATH=\"\$PATH:${INSTALL_DIR}\"" >> "$shell_config"
        fi

        success "PATH updated in ${shell_config}"
        warn "Run 'source ${shell_config}' or restart your terminal to use agate"
    else
        warn "Could not detect shell configuration file"
        warn "Please add ${INSTALL_DIR} to your PATH manually"
    fi
}

# Check for existing installation
check_existing_installation() {
    if [[ -f "${INSTALL_DIR}/${BINARY_NAME}" ]]; then
        local current_version
        current_version=$("${INSTALL_DIR}/${BINARY_NAME}" --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' || echo "unknown")

        if [[ "$current_version" == "$1" ]]; then
            success "Agate v${current_version} is already installed"
            exit 0
        else
            warn "Found existing installation (v${current_version})"
            info "Upgrading to v$1..."
        fi
    fi
}

# Main installation flow
main() {
    # Parse arguments first to get agent color
    local install_tmux=""
    local agent=""
    local agent_display=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --install-tmux|-t)
                install_tmux="yes"
                shift
                ;;
            --agent|-a)
                agent="$2"
                shift 2
                ;;
            *)
                # Ignore unknown options for curl pipe compatibility
                shift
                ;;
        esac
    done

    # Set agent color if agent is specified
    if [[ -n "$agent" ]]; then
        AGENT_COLOR=$(get_agent_color "$agent")
        agent_display=$(get_agent_name "$agent")
        if [[ -z "$AGENT_COLOR" ]] || [[ -z "$agent_display" ]]; then
            warn "Unknown agent: $agent"
            agent=""
            AGENT_COLOR=""
        fi
    fi

    if [[ -n "$agent" ]]; then
        printf "\n"
        printf "${AGENT_COLOR}╔═════════════════════════════════════════════════════════════╗${NC}\n"
        printf "${AGENT_COLOR}║${NC}                                                             ${AGENT_COLOR}║${NC}\n"
        printf "${AGENT_COLOR}║${NC} ${BOLD}Agate installer                                             ${AGENT_COLOR}║${NC}\n"
        printf "${AGENT_COLOR}║${NC}                                                             ${AGENT_COLOR}║${NC}\n"
        printf "${AGENT_COLOR}╚═════════════════════════════════════════════════════════════╝${NC}\n\n"
    else
        printf "\n${BOLD}Agate installer${NC}\n\n"
    fi

    # Set environment variables
    INSTALL_TMUX="${install_tmux:-no}"

    # Get latest version
    local version
    if ! version=$(get_latest_version); then
        die "Unable to fetch latest version from GitHub API"
    fi
    print_success "Latest version: v${version}"

    # Detect platform
    local platform
    platform=$(detect_platform)
    print_success "Detected ${platform}"

    # Check existing installation
    check_existing_installation "$version"

    # Check dependencies
    check_dependencies

    # Install Agate
    install_agate "$platform" "$version"

    # Update shell configuration
    update_shell_config

    # Final success message
    echo ""
    printf "${GREEN}${BOLD}🚀 Installation Complete!${NC}\n"
    echo ""

    if [[ -n "$agent" ]]; then
        if command_exists "$agent"; then
            printf "${GREEN}${BOLD}✓ ${AGENT_COLOR}${agent}${NC}${GREEN}${BOLD} verified and ready${NC}\n"
        fi
        echo ""
        print_dim "Reload your shell:"
        printf "  ${CYAN}source ~/.$(basename "$SHELL")rc${NC}\n"
        echo ""
        printf "${BOLD}Start agate${NC}\n"
        printf "  ${CYAN}agate ${AGENT_COLOR}${agent}${NC}\n"
    else
        echo ""
        print_dim "Reload your shell:"
        printf "  ${CYAN}source ~/.$(basename "$SHELL")rc${NC}\n"
        echo ""
        printf "${BOLD}Start agate${NC}\n"
        printf "  ${CYAN}agate claude${NC}\n"
        printf "  ${CYAN}agate copilot${NC}\n"
        printf "  ${CYAN}agate cursor${NC}\n"
    fi
    echo ""
    print_dim "Documentation: ${BLUE}https://github.com/${REPO_OWNER}/${REPO_NAME}${NC}"
    echo ""
}

# Support piping to bash
if [[ "${BASH_SOURCE[0]:-}" == "${0}" ]] || [[ -z "${BASH_SOURCE[0]:-}" ]]; then
    main "$@"
fi